package org.papervision3d.objects.special {	import flash.geom.Rectangle;		import org.papervision3d.core.culling.IObjectCuller;	import org.papervision3d.core.geom.renderables.Vertex3D;	import org.papervision3d.core.geom.renderables.Vertex3DInstance;	import org.papervision3d.core.math.Matrix3D;	import org.papervision3d.core.proto.GeometryObject3D;	import org.papervision3d.core.render.command.AbstractRenderListItem;	import org.papervision3d.core.render.command.RenderVectorShape;	import org.papervision3d.core.render.data.RenderSessionData;	import org.papervision3d.materials.special.VectorShapeMaterial;	import org.papervision3d.objects.DisplayObject3D;	import org.papervision3d.objects.special.Graphics3D;			/**	 * @author Mark Barcinski	 */	public class VectorShape3D extends DisplayObject3D {		public var graphicsCommands:Array;		public var renderCommand : RenderVectorShape;		public var graphics : Graphics3D;		public var ready:Boolean = false;  // has circle been drawn?				public function VectorShape3D(material:VectorShapeMaterial , vertices : Array = null, name : String = null, initObject : Object = null) {			graphics = new Graphics3D(this);			graphicsCommands = [];			renderCommand = new RenderVectorShape( this);			renderCommand.renderer = material;			this.material = material;			super( name, new GeometryObject3D(), initObject );			this.geometry.vertices = vertices || new Array();		}                // Attempt to clean up references when removing from container        public function uninit():void {            this.graphics.uninit();            this.graphics = null;            this.renderCommand.uninit();            this.material = null;            this.geometry.vertices = null;            while (this.graphicsCommands.length > 0) {                this.graphicsCommands.pop();            }            this.graphicsCommands = null;            return;        }        		public override function project( parent :DisplayObject3D,  renderSessionData:RenderSessionData ):Number		{			var screenZ:Number = 0;			var visible:Boolean = false;						super.project( parent, renderSessionData );			if( this.culled )				return 0;							if( renderSessionData.camera is IObjectCuller )				return projectFrustum(parent, renderSessionData);							var view:Matrix3D = this.view,			// Camera			m11 :Number = view.n11,			m12 :Number = view.n12,			m13 :Number = view.n13,			m21 :Number = view.n21,			m22 :Number = view.n22,			m23 :Number = view.n23,			m31 :Number = view.n31,			m32 :Number = view.n32,			m33 :Number = view.n33,			vx	:Number,			vy	:Number,			vz	:Number,			s_x	:Number,			s_y	:Number,			s_z	:Number,			vertex:org.papervision3d.core.geom.renderables.Vertex3D, 			screen:Vertex3DInstance,			persp :Number,			vertices :Array  = this.geometry.vertices,			i        :int    = vertices.length,			focus    :Number = renderSessionData.camera.focus,			fz       :Number = focus * renderSessionData.camera.zoom;						while( vertex = vertices[--i] )			{				// Center position				vx = vertex.x;				vy = vertex.y;				vz = vertex.z;								s_z = vx * m31 + vy * m32 + vz * m33 + view.n34;				//TODO this isn't the best solution				if(s_z < 0 )s_z = 0;								screen = vertex.vertex3DInstance;								s_x = vx * m11 + vy * m12 + vz * m13 + view.n14;				s_y = vx * m21 + vy * m22 + vz * m23 + view.n24;								persp = fz / (focus + s_z);				screen.x = s_x * persp;				screen.y = s_y * persp;				screen.z = s_z;				screenZ += s_z;								//screen.visible = s_z > 0;				visible = ( s_z > 0 || visible);							}						if(visible)			{				renderSessionData.renderer.addToRenderList(renderCommand);				this.screenZ = screenZ / vertices.length;				renderCommand.screenDepth = this.screenZ;			}									return this.screenZ; //screenZ;		}				public function projectFrustum( parent :DisplayObject3D, renderSessionData:RenderSessionData ):Number 		{			var screenZ:Number = 0;			var visible:Boolean = false;						var view:Matrix3D = this.view,				viewport:Rectangle = renderSessionData.camera.viewport,				m11 :Number = view.n11,				m12 :Number = view.n12,				m13 :Number = view.n13,				m21 :Number = view.n21,				m22 :Number = view.n22,				m23 :Number = view.n23,				m31 :Number = view.n31,				m32 :Number = view.n32,				m33 :Number = view.n33,				m41 :Number = view.n41,				m42 :Number = view.n42,				m43 :Number = view.n43,				vx	:Number,				vy	:Number,				vz	:Number,				s_x	:Number,				s_y	:Number,				s_z	:Number,				s_w :Number,				vpw :Number = viewport.width / 2,				vph :Number = viewport.height / 2,				vertex:Vertex3D, 				screen:Vertex3DInstance,				vertices :Array  = this.geometry.vertices,				i        :int    = vertices.length;						while( vertex = vertices[--i] )			{				// Center position				vx = vertex.x;				vy = vertex.y;				vz = vertex.z;				// NOTE: can remove all vz calculations, due to shapes being 2D				s_z = vx * m31 + vy * m32 + vz * m33 + view.n34;				s_w = vx * m41 + vy * m42 + vz * m43 + view.n44;								screen = vertex.vertex3DInstance;								// to normalized clip space (0.0 to 1.0)				// NOTE: can skip and simply test (s_z < 0) and save a div				s_z /= s_w;								// TODO i don't know what do when sreen.z < 0 this helps a little bit but still doens't render correctly				//s_w = Math.abs(s_w);								// is point between near- and far-plane?				screen.visible = (s_z > 0 && s_z < 1);								// to normalized clip space (-1,-1) to (1, 1)				s_x = (vx * m11 + vy * m12 + vz * m13 + view.n14) / s_w;				s_y = (vx * m21 + vy * m22 + vz * m23 + view.n24) / s_w;								// NOTE: optionally we can flag screen verts here 				//screen.visible = (s_x > -1 && s_x < 1 && s_y > -1 && s_y < 1);								// project to viewport.				screen.x = s_x * vpw;				screen.y = s_y * vph;								//Papervision3D.logger.debug( "sx:" + screen.x + " " +screen.y );				// NOTE: z not lineair, value increases when nearing far-plane.				screen.z = s_z;				screenZ += s_z;				visible = ( screen.visible || visible);							}						if(visible)			{				renderSessionData.renderer.addToRenderList(renderCommand);				this.screenZ = screenZ / vertices.length;				renderCommand.screenDepth = this.screenZ;			}						return this.screenZ; //screenZ;		}	}}